#include "gcodeReader.h"
#include "helpers.h"

#ifdef USING_OPTIX
std::string ofToDataPath(std::string s) { return s; }
#endif

//--------------------------------------------------------------
float gcodeArgFloat(std::string arg, int startPos = 1) {
	// Extracts an floating point value from a Gcode argument
	return std::stof( arg.substr(startPos, arg.size() - 1) );
}

//--------------------------------------------------------------
float safe_acosf(float v) {
	if (v > 1) return 0.0f;
	if (v < -1) return PI;
	return acosf(v);
}

//--------------------------------------------------------------
void GcodeReader::readPathsFromGcode(std::string gcodeFileName) {
	// Clear any existing path data
	clearPaths();

	// Get the filepath to the data directory
	std::string filePath = ofToDataPath(gcodeFileName);

	// Open text file and read data from it
	std::ifstream infile(filePath);

	if (!infile.is_open()) {
		std::cout << "Error: couldn't open file " << gcodeFileName << " for reading\n";
		return;
	}
	else {
		std::cout << "Reading gcode from file " << gcodeFileName << "\n";
	}

	std::string curLine;
	std::string curCommand;
	std::string curArg;
	float curX, curY, curZ, curE, curF;
	float prevX, prevY, prevZ, prevE, prevF;

	// Initialize values
	curX = curY = curZ = curE = curF = 0.0f;
	prevX = prevY = prevZ = prevE = prevF = 0.0f;

	// Get Gcode statements a line at a time
	int numLineSegments = 0;
	float curLayerZ = 0;
	float curLayerThickness = 0;
	float curNozzleWidth = 0;
	bool startNewPathSegment = true;
	PathSegment* curPathSegment;
	while (getline(infile, curLine)) {

		// Separate curLine in args
		std::istringstream ss(curLine);
		std::vector<std::string> args;
		while (!ss.eof()) {
			std::string curArg;
			ss >> curArg;
			args.push_back(curArg);
		}

		// Current line is a comment
		if (curLine[0] == ';') {
			// Does curLine indicate which type of slicer is being used?
			if (curLine.substr(0, 20) == ";Generated with Cura") {
				mySlicer = slicer_cura;
				std::cout << "Setting slicer to Cura\n";
			}
			else if (curLine.substr(0, 26) == "; generated by PrusaSlicer") {
				mySlicer = slicer_prusaSlicer;
				std::cout << "Setting slicer to PrusaSlicer\n";
			}
			else if (curLine.substr(0, 32) == "; G-Code generated by Simplify3D") {
				mySlicer = slicer_simplify3D;
				std::cout << "Setting slicer to Simplify3D\n";
			}

			// Does the curLine indicate the nozzle width?
			switch (mySlicer) {
			case slicer_none:
			case slicer_cura:
				if (curLine.substr(0, 17) == ";NOZZLE_DIAMETER:") {
					curNozzleWidth = gcodeArgFloat(args[0], 17);
					// std::cout << "Cura: Setting nozzle width to " << curNozzleWidth << "\n";
				}
				break;

			case slicer_prusaSlicer:
				if (curLine.substr(0, 7) == ";WIDTH:") {
					curNozzleWidth = gcodeArgFloat(args[0], 7);
					// std::cout << "PrusaSlicer: Setting nozzle width to " << curNozzleWidth << "\n";
				}
				break;

			case slicer_simplify3D:
				if (curLine.substr(0, 6) == "; tool") {
					curNozzleWidth = gcodeArgFloat(args[3], 1);
					// std::cout << "simplify3D: Setting nozzle width to " << curNozzleWidth << "\n";
				}
				break;
			}
		}

		// Linear move command
		if (args[0] == "G0" || args[0] == "G1") {
			for (unsigned int i = 1; i < args.size(); i++) {
				// If the next argument is a comment we need to ignore the rest of this line
				if (args[i][0] == ';') {
					break;
				}

				// Parse the argument
				if (args[i][0] == 'X') {
					curX = gcodeArgFloat(args[i]);
				}
				else if (args[i][0] == 'Y') {
					curY = gcodeArgFloat(args[i]);
				}
				else if (args[i][0] == 'Z') {
					curZ = gcodeArgFloat(args[i]);
				}
				else if (args[i][0] == 'E') {
					curE = gcodeArgFloat(args[i]);
				}
				else if (args[i][0] == 'F') {
					curF = gcodeArgFloat(args[i]);
				}
			}
		}

		// Set position command
		if (args[0] == "G92") {
			for (unsigned int i = 1; i < args.size(); i++) {
				// If the next argument is a comment we need to ignore the rest of this line
				if (args[i][0] == ';') {
					break;
				}

				// Parse the argument
				if (args[i][0] == 'E') {
					curE = gcodeArgFloat(args[i]);
					prevE = curE;
				}
			}
		}

		// If the E value has gone up and we've changed x or y we've got a new line segment
		if (curE > prevE && (curX != prevX || curY != prevY)) {
			if (curZ != curLayerZ) {
				// We've changed the value of Z since the last line segment, so we've got a new layerZ
				curLayerThickness = curZ - curLayerZ;
				curLayerZ = curZ;
				// std::cout << "Setting layer thickness to " << curLayerThickness << "\n";
			}

			if (startNewPathSegment) {
				// We're starting a new path segment
				PathSegment newPathSegment;
				newPathSegment.layerThickness = curLayerThickness;
				newPathSegment.nozzleWidth = curNozzleWidth;
				myPaths.push_back(newPathSegment);
				curPathSegment = &myPaths.back();
				startNewPathSegment = false;

				// Add the first position to the path segment
				curPathSegment->positions.push_back(make_float3(prevX, prevY, prevZ));
				curPathSegment->extrusions.push_back(prevE);
			}



			// Add current position to the path segment
			curPathSegment->positions.push_back(make_float3(curX, curY, curZ));
			curPathSegment->extrusions.push_back(curE);

			numLineSegments++;
		}

		// If we've moved and E hasn't increased we're potentially starting a new segment
		if (curE <= prevE && (curX != prevX || curY != prevY || curZ != prevZ)) {
			// Reverse extrusion, which means we've just ended any path segment that we were drawing
			startNewPathSegment = true;
		}

		prevX = curX;
		prevY = curY;
		prevZ = curZ;
		prevE = curE;
		prevF = curF;
	}

	std::cout << "Total number line segments: " << numLineSegments << "\n";
}

//--------------------------------------------------------------
void GcodeReader::printPaths() {
	for (unsigned int i = 0; i < myPaths.size(); i++) {
		std::cout << "\nPath: " << i << ":\n";
		for (unsigned int j = 0; j < myPaths[i].positions.size() - 1; j++) {
			std::cout << "  (" << myPaths[i].positions[j].x << ", " << myPaths[i].positions[j].y << ", " << myPaths[i].positions[j].z << ") to ("
				<< myPaths[i].positions[j + 1].x << ", " << myPaths[i].positions[j + 1].y << ", " << myPaths[i].positions[j + 1].z << ")\n";
		}
	}
}

//--------------------------------------------------------------
void GcodeReader::cleanupPaths(float minSegmentLength) {
	// Loop through all the paths
	for (unsigned int i = 0; i < myPaths.size(); i++) {
		// Go through each path from the penultimate position send last deleting any positions that are too close to the next one
		for (unsigned int j = myPaths[i].positions.size() - 2; j > 0; j--) {
			float3 p0 = myPaths[i].positions[j];
			float3 p1 = myPaths[i].positions[j + 1];
			if (length(p0 - p1) < minSegmentLength) {
				// Erase the jth value from the path
				myPaths[i].positions.erase(myPaths[i].positions.begin() + j);
			}
		}
	}
}

//--------------------------------------------------------------
void GcodeReader::convertPathsToLines() {
	// Clear any existing mesh data
	myMesh.clear();
	myMesh.setMode(OF_PRIMITIVE_LINES);

	for (unsigned int i = 0; i < myPaths.size(); i++) {
		for (unsigned int j = 0; j < myPaths[i].positions.size() - 1; j++) {
			myMesh.addVertex(myPaths[i].positions[j]);
			myMesh.addVertex(myPaths[i].positions[j+1]);
		}
	}
}

//--------------------------------------------------------------
void GcodeReader::convertPathsToMesh(float nozzleWidth, float layerThickness, int tubeResolution, int endCapResolution, float maxAngle) {
	// Clear any existing mesh data
	myMesh.clear();
	myMesh.setMode(OF_PRIMITIVE_TRIANGLES);

	// Convert maxAngle to a cosine so that we can use dot products
	float cosMaxAngle = cosf(PI * maxAngle / 180.0f);

	// First pass: create tubes

	// Loop through all the paths
	for (unsigned int i = 0; i < myPaths.size(); i++) {
		// Get the index for the first vertex for the current path
		int firstIndex = myMesh.getNumVertices();

		// If path specifies nozzleWidth use this value from now on
		if (myPaths[i].nozzleWidth > 0) {
			nozzleWidth = myPaths[i].nozzleWidth;
		}

		// If path specifies layerThickness use this value from now on
		if (myPaths[i].layerThickness > 0) {
			layerThickness = myPaths[i].layerThickness;
		}

		// For each point on a path we declare a set of vertices for the cross section
		// Whether we declare 1 or 2 cross sections depends on the angle between consecutive points
		// Note: we assume that all paths are in the XY plane

		if (myPaths[i].positions.size() > 2) {
			for (unsigned int j = 0; j < myPaths[i].positions.size(); j++) {

				// Need to decide whether to create 1 blended or two separate cross sections for the current point

				// For each cross section we need a point, axis direction, and a scaling factor
				// for the case that we're using a single cross section that's blending between
				// two line segments

				// If we're at the first point or last point, create a single cross section
				if (j == 0) {
					addCrossSection(
						myPaths[i].positions[j],
						normalize(myPaths[i].positions[j + 1] - myPaths[i].positions[j]),
						1.0f,
						nozzleWidth, layerThickness, tubeResolution);
				}
				else if (j == myPaths[i].positions.size() - 1) {
					addCrossSection(
						myPaths[i].positions[j],
						normalize(myPaths[i].positions[j] - myPaths[i].positions[j - 1]),
						1.0f,
						nozzleWidth, layerThickness, tubeResolution);
				}
				// If we're at an intermediate point we need to check the angle between the lines
				else {
					float3 d0 = normalize(myPaths[i].positions[j] - myPaths[i].positions[j - 1]);
					float3 d1 = normalize(myPaths[i].positions[j + 1] - myPaths[i].positions[j]);

					// Test the angle between the lines
					if (dot(d0, d1) > cosMaxAngle) {
						// The angle between the lines is small, so we create a single blended cross-section
						float theta = safe_acosf(dot(d0, d1));
						float scaleFactor = 1.0f / cosf(0.5f * theta);
						addCrossSection(
							myPaths[i].positions[j],
							normalize(d0 + d1),
							scaleFactor,
							nozzleWidth, layerThickness, tubeResolution);
					}
					else {
						// The angle between the lines is large, so we create two cross cross-sections
						addCrossSection(
							myPaths[i].positions[j],
							d0,
							1.0,
							nozzleWidth, layerThickness, tubeResolution);
						addCrossSection(
							myPaths[i].positions[j],
							d1,
							1.0,
							nozzleWidth, layerThickness, tubeResolution);
					}
				}
			}
		}

		int lastIndex = myMesh.getNumVertices();

		// Connect up the vertices to form tubes
		for (int j = firstIndex; j < lastIndex - tubeResolution; j += tubeResolution) {
			for (int k = 0; k < tubeResolution; k++) {
				int jj = j + tubeResolution;
				int kk = (k + 1) % tubeResolution;
				myMesh.addTriangle(j + k, j + kk, jj + k);
				myMesh.addTriangle(j + kk, jj + kk, jj + k);
			}
		}
	}

	// Second pass: create end caps

	if (endCapResolution > 0) {
		// Loop through all the paths
		for (unsigned int i = 0; i < myPaths.size(); i++) {
			int numSegments = myPaths[i].positions.size();
			if (numSegments >= 2) {
				// If path specifies nozzleWidth use this value from now on
				if (myPaths[i].nozzleWidth > 0) {
					nozzleWidth = myPaths[i].nozzleWidth;
				}

				addEndCap(
					myPaths[i].positions[0],
					normalize(myPaths[i].positions[0] - myPaths[i].positions[1]),
					nozzleWidth, layerThickness, tubeResolution, endCapResolution);

				addEndCap(
					myPaths[i].positions[numSegments - 1],
					normalize(myPaths[i].positions[numSegments - 1] - myPaths[i].positions[numSegments - 2]),
					nozzleWidth, layerThickness, tubeResolution, endCapResolution);
			}
		}
	}
}

//--------------------------------------------------------------
float3 GcodeReader::getMidPos() {
	float3 minPos = myPaths[0].positions[0];
	float3 maxPos = myPaths[0].positions[0];

	for (unsigned int i = 0; i < myPaths.size(); i++) {
		for (unsigned int j = 0; j < myPaths[i].positions.size() - 1; j++) {
			if (myPaths[i].positions[j].x < minPos.x) minPos.x = myPaths[i].positions[j].x;
			if (myPaths[i].positions[j].y < minPos.y) minPos.y = myPaths[i].positions[j].y;
			if (myPaths[i].positions[j].z < minPos.z) minPos.z = myPaths[i].positions[j].z;
			if (myPaths[i].positions[j].x > maxPos.x) maxPos.x = myPaths[i].positions[j].x;
			if (myPaths[i].positions[j].y > maxPos.y) maxPos.y = myPaths[i].positions[j].y;
			if (myPaths[i].positions[j].z > maxPos.z) maxPos.z = myPaths[i].positions[j].z;
		}
	}

	return 0.5 * (minPos + maxPos);
}

//--------------------------------------------------------------
void GcodeReader::draw() {
	myMesh.draw();
}

//--------------------------------------------------------------
void GcodeReader::clearPaths() {
	if (myPaths.size() > 0) {
		for (unsigned int i = 0; i < myPaths.size(); i++) {
			myPaths[i].positions.clear();
			myPaths[i].extrusions.clear();
		}
	}
	
	myPaths.clear();
}

//--------------------------------------------------------------
void GcodeReader::addCrossSection(float3 p, float3 d, float scaleFactor, float nozzleWidth, float layerThickness, int tubeResolution) {
	// Basis vectors for cross section (note: we assume that d has already been normalized)
	float3 v = make_float3(0, 0, 1);
	float3 u = normalize(cross(d, v));

	// Quick exit if u is a NaN
	if (std::isnan(u.x))
		return;

	// Calculate angle to start cross sections so that a flat section of polygon is horizontal
	float theta0 = PI / tubeResolution;

	// Calculate radius and offset to make each cross section a capsule
	float radius = 0.5f * layerThickness / cosf(theta0);
	float offset = 0.5f * nozzleWidth - radius;

	// Calculate vertices for the cross section around p0 (which should be capsule like rather than eliptical)
	for (int k = 0; k < tubeResolution; k++) {
		// Need to offset the angles so that we have a flat top and flat bottom for the cross section, and
		// need to scale vertically so that layers meet each other seamlessly
		float theta = theta0 + TWO_PI * k / tubeResolution;
		float offsetDir = (k < tubeResolution / 2) ? 1.0f : -1.0f;
		myMesh.addVertex(p +
			scaleFactor * (offsetDir * offset + radius * sinf(theta)) * u +
			(radius * cosf(theta) - 0.5f * layerThickness) * v);

		// For the normal we fix the normal to vertical around the top and bottom of the capsule
		if (k == 0 || k == tubeResolution - 1)
			myMesh.addNormal(make_float3(0, 0, 1));
		else if (k == tubeResolution % 2 - 1 || k == tubeResolution % 2)
			myMesh.addNormal(make_float3(0, 0, -1));
		else
			myMesh.addNormal(normalize(scaleFactor * sinf(theta) * u + cosf(theta) * v));
	}
}

//--------------------------------------------------------------
void GcodeReader::addEndCap(float3 p, float3 d, float nozzleWidth, float layerThickness, int tubeResolution, int endCapResolution) {
	// Basis vectors for cross section (note: we assume d has already been normalized)
	float3 v = make_float3(0, 0, 1);
	float3 u = normalize(cross(d, v));
	float3 w = d;

	// Quick exit if u is a NaN
	if (std::isnan(u.x))
		return;

	int halfTubeResolution = tubeResolution / 2;

	// Calculate angle to start cross sections so that a flat section of polygon is horizontal
	float theta0 = PI / tubeResolution;

	// Calculate radius and offset to make each cross section a capsule
	float radius = 0.5f * layerThickness / cosf(theta0);
	float offset = 0.5f * nozzleWidth - radius;

	// Get index of the first end cap vertex
	int firstIndex = myMesh.getNumVertices();

	// Calculate vertices for the cross section around p (which should be capsule like rather than eliptical)
	for (int j = 0; j <= endCapResolution; j++) {
		float phi = PI * j / endCapResolution;
		for (int k = 0; k < halfTubeResolution; k++) {
			// Need to offset the angles so that we have a flat top and flat bottom for the cross section, and
			// need to scale vertically so that layers meet each other seamlessly
			float theta = theta0 + TWO_PI * k / tubeResolution;
			myMesh.addVertex(p +
				cosf(phi) * (offset + radius * sinf(theta)) * u +
				(radius * cosf(theta) - 0.5f * layerThickness) * v +
				sinf(phi) * (offset + radius * sinf(theta)) * w);
			// Fix normal to vertical if it's the first or last vertex
			if (k == 0)
				myMesh.addNormal(make_float3(0, 0, 1));
			else if (k == halfTubeResolution - 1)
				myMesh.addNormal(make_float3(0, 0, -1));
			else
				myMesh.addNormal(normalize(cosf(phi) * sinf(theta) * u + cosf(theta) * v + sinf(phi) * sinf(theta) * w));
		}
	}

	// Add upper and lower centre vertices
	int upperCenterVertIndex = myMesh.getNumVertices();
	myMesh.addVertex(p);
	myMesh.addNormal(make_float3(0, 0, 1));
	
	int lowerCenterVertIndex = myMesh.getNumVertices();
	myMesh.addVertex(p - 1.0f * layerThickness * v);
	myMesh.addNormal(make_float3(0, 0, -1));

	// Connect up the end cap vertices into triangles
	for (int j = 0; j < endCapResolution; j++) {

		// Add triangle for the top section
		myMesh.addTriangle(
			upperCenterVertIndex,
			firstIndex + j * halfTubeResolution,
			firstIndex + (j + 1) * halfTubeResolution);

		// Add triangle for the lower section
		myMesh.addTriangle(
			lowerCenterVertIndex,
			firstIndex + (j + 1) * halfTubeResolution + (halfTubeResolution - 1),
			firstIndex + j * halfTubeResolution + (halfTubeResolution - 1));

		// Add triangles for the sections between
		for (int k = 0; k < halfTubeResolution - 1; k++) {
			myMesh.addTriangle(
				firstIndex + j * halfTubeResolution + k,
				firstIndex + j * halfTubeResolution + (k + 1),
				firstIndex + (j + 1) * halfTubeResolution + k);
			myMesh.addTriangle(
				firstIndex + j * halfTubeResolution + (k + 1),
				firstIndex + (j + 1) * halfTubeResolution + (k + 1),
				firstIndex + (j + 1) * halfTubeResolution + k);
		}
	}
}